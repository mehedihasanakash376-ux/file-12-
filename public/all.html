<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/png" href="/icon.png">
  <meta name="theme-color" content="#00d4ff">
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <title>All Posts - Nafij's Social Share</title>
</head>
<body>
  <!-- Header -->
  <header class="header" role="banner">
    <h1>ğŸš€ Nafij's Social Share</h1>
    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
      <span id="theme-icon">ğŸŒ™</span>
    </button>
  </header>

  <!-- Main Content -->
  <main class="container" role="main">
    <!-- Navigation -->
    <nav class="card navigation-card" role="navigation" aria-label="Site navigation">
      <div class="nav-buttons">
        <a href="/" class="btn btn-outline">ğŸ  Home</a>
        <a href="/post.html" class="btn btn-outline">âœï¸ New Post</a>
        <a href="/all.html" class="btn btn-primary">ğŸ“‹ All Posts</a>
        <a href="/profile.html" class="btn btn-outline">ğŸ‘¤ Profile</a>
        <a href="/search.html" class="btn btn-outline">ğŸ” Search</a>
        <a href="/admin.html" class="btn btn-outline">âš™ï¸ Admin</a>
      </div>
    </nav>

    <!-- Posts Feed -->
    <section class="feed-section" id="feed-section" aria-labelledby="feed-heading">
      <div class="feed-header">
        <h2 id="feed-heading">ğŸ“‹ All Posts</h2>
        <div class="feed-controls">
          <button class="btn btn-outline" id="refresh-btn">ğŸ”„ Refresh</button>
          <select id="sort-select" class="sort-select">
            <option value="newest">ğŸ•’ Newest First</option>
            <option value="oldest">â° Oldest First</option>
            <option value="most-liked">â¤ï¸ Most Liked</option>
            <option value="most-commented">ğŸ’¬ Most Commented</option>
          </select>
        </div>
      </div>
      
      <div id="posts-feed" class="posts-container" role="feed" aria-live="polite">
        <div class="loading-skeleton">
          <div class="skeleton-post"></div>
          <div class="skeleton-post"></div>
          <div class="skeleton-post"></div>
        </div>
      </div>

      <div class="load-more-container" id="load-more-container" style="display: none;">
        <button class="btn btn-outline" id="load-more-btn">ğŸ“¥ Load More Posts</button>
      </div>
    </section>
  </main>

  <!-- Scroll to Top Button -->
  <button class="scroll-top" id="scroll-top" aria-label="Scroll to top">
    â†‘
  </button>

  <!-- Lightbox Modal -->
  <div id="lightbox" class="lightbox" role="dialog" aria-modal="true" aria-labelledby="lightbox-title">
    <div class="lightbox-content">
      <button class="lightbox-close" aria-label="Close lightbox">&times;</button>
      <div class="lightbox-media"></div>
      <div class="lightbox-controls">
        <button class="btn btn-outline" id="lightbox-download">â¬‡ï¸ Download</button>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script>
    // Global state
    let allPosts = [];
    let currentPage = 0;
    let isLoading = false;
    let hasMorePosts = true;
    let currentSort = 'newest';
    const POSTS_PER_PAGE = 10;

    // Theme Management
    const themeToggle = document.getElementById('theme-toggle');
    const themeIcon = document.getElementById('theme-icon');
    const body = document.body;

    // Load saved theme
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      body.classList.add('dark');
      themeIcon.textContent = 'â˜€ï¸';
    }

    themeToggle.addEventListener('click', () => {
      body.classList.toggle('dark');
      const isDark = body.classList.contains('dark');
      themeIcon.textContent = isDark ? 'â˜€ï¸' : 'ğŸŒ™';
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
    });

    // Username Management
    const savedUsername = localStorage.getItem('username') || '';

    // Posts loading and display
    async function loadPosts(reset = false) {
      if (isLoading) return;
      
      isLoading = true;
      
      if (reset) {
        currentPage = 0;
        hasMorePosts = true;
        allPosts = [];
      }

      try {
        let url = `/api/posts?page=${currentPage}&limit=${POSTS_PER_PAGE}`;
        
        const response = await fetch(url);
        const posts = await response.json();
        
        if (posts.length < POSTS_PER_PAGE) {
          hasMorePosts = false;
        }
        
        if (reset) {
          allPosts = posts;
        } else {
          allPosts = [...allPosts, ...posts];
        }
        
        // Sort posts based on current sort option
        sortPosts();
        displayPosts(reset);
        
        currentPage++;
        
        // Update load more button
        const loadMoreContainer = document.getElementById('load-more-container');
        if (hasMorePosts && allPosts.length >= POSTS_PER_PAGE) {
          loadMoreContainer.style.display = 'block';
        } else {
          loadMoreContainer.style.display = 'none';
        }
        
      } catch (error) {
        console.error('Error loading posts:', error);
        showNotification('Failed to load posts', 'error');
      } finally {
        isLoading = false;
      }
    }

    function sortPosts() {
      switch (currentSort) {
        case 'oldest':
          allPosts.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
          break;
        case 'most-liked':
          allPosts.sort((a, b) => (b.likes || 0) - (a.likes || 0));
          break;
        case 'most-commented':
          allPosts.sort((a, b) => (b.comments?.length || 0) - (a.comments?.length || 0));
          break;
        case 'newest':
        default:
          allPosts.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
          break;
      }
    }

    function displayPosts(reset = false) {
      const container = document.getElementById('posts-feed');
      
      if (allPosts.length === 0) {
        container.innerHTML = '<div class="empty-state">No posts yet. Be the first to share something! ğŸš€</div>';
        return;
      }

      if (reset) {
        container.innerHTML = '';
      }

      const newPostsHTML = allPosts.slice(reset ? 0 : allPosts.length - POSTS_PER_PAGE).map(post => createPostHTML(post)).join('');
      
      if (reset) {
        container.innerHTML = newPostsHTML;
      } else {
        container.insertAdjacentHTML('beforeend', newPostsHTML);
      }
      
      // Animate in new posts
      setTimeout(() => {
        document.querySelectorAll('.post-card:not(.fade-in)').forEach((card, index) => {
          setTimeout(() => {
            card.classList.add('fade-in');
          }, index * 100);
        });
      }, 100);
    }

    function createPostHTML(post) {
      const timeAgo = getTimeAgo(new Date(post.createdAt));
      const userName = post.user || 'Anonymous';
      const commentsCount = post.comments?.length || 0;
      
      let mediaHTML = '';
      if (post.media && post.media.length > 0) {
        mediaHTML = post.media.map(file => {
          const mediaUrl = file.url;
          
          if (file.mimetype?.startsWith('image/')) {
            return `
              <div class="post-media">
                <img src="${mediaUrl}" alt="Post image" onclick="openLightbox('${mediaUrl}', 'image')" loading="lazy" />
                <button class="media-download" onclick="downloadFile('${mediaUrl}', '${file.originalName}')" aria-label="Download image">â¬‡ï¸</button>
              </div>
            `;
          } else if (file.mimetype?.startsWith('video/')) {
            return `
              <div class="post-media">
                <video controls preload="metadata" poster="">
                  <source src="${mediaUrl}" type="${file.mimetype}">
                  Your browser does not support the video tag.
                </video>
                <button class="media-download" onclick="downloadFile('${mediaUrl}', '${file.originalName}')" aria-label="Download video">â¬‡ï¸</button>
              </div>
            `;
          } else if (file.mimetype?.startsWith('audio/')) {
            return `
              <div class="post-media">
                <audio controls preload="metadata">
                  <source src="${mediaUrl}" type="${file.mimetype}">
                  Your browser does not support the audio tag.
                </audio>
                <button class="media-download" onclick="downloadFile('${mediaUrl}', '${file.originalName}')" aria-label="Download audio">â¬‡ï¸</button>
              </div>
            `;
          } else {
            return `
              <div class="post-media">
                <a href="${mediaUrl}" download target="_blank" class="file-attachment" aria-label="Download file">
                  ğŸ“ Download ${file.originalName}
                </a>
              </div>
            `;
          }
        }).join('');
      }

      // Build comments HTML
      const commentsHTML = buildCommentsHTML(post.comments || [], post._id);

      return `
        <article class="post-card" data-post-id="${post._id}">
          <div class="post-header">
            <div class="post-author">
              <div class="author-avatar">${userName.charAt(0).toUpperCase()}</div>
              <div class="author-info">
                <strong>${userName}</strong>
                <span class="post-time">${timeAgo}</span>
              </div>
            </div>
          </div>
          
          ${post.text ? `<div class="post-content">${post.text}</div>` : ''}
          
          ${mediaHTML}
          
          <div class="post-actions">
            <button class="like-btn" onclick="likePost('${post._id}')">
              <span class="reaction-icon">â¤ï¸</span>
              <span class="like-count">${post.likes || 0}</span>
            </button>
            <button class="comment-btn" onclick="toggleComments('${post._id}')">
              <span class="reaction-icon">ğŸ’¬</span>
              <span class="comment-count">${commentsCount}</span>
            </button>
            <button class="share-btn" onclick="sharePost('${post._id}')">
              <span class="reaction-icon">ğŸ”—</span>
              <span>Share</span>
            </button>
          </div>

          <div class="comments-section" id="comments-${post._id}" style="display: none;">
            <div class="comment-form">
              <input type="text" class="comment-input" placeholder="Write a comment..." maxlength="1000" />
              <button class="btn btn-primary comment-submit" onclick="addComment('${post._id}', this)">Post</button>
            </div>
            <div class="comments-list" id="comments-list-${post._id}">
              ${commentsHTML}
            </div>
          </div>
        </article>
      `;
    }

    function buildCommentsHTML(comments, postId, parentId = null, level = 0) {
      if (!comments || comments.length === 0) return '';
      
      const filteredComments = comments.filter(comment => comment.parentId === parentId);
      
      return filteredComments.map(comment => {
        const timeAgo = getTimeAgo(new Date(comment.createdAt));
        const replies = buildCommentsHTML(comments, postId, comment.id, level + 1);
        const hasReplies = replies.length > 0;
        
        return `
          <div class="comment ${level > 0 ? 'comment-reply' : ''}" data-comment-id="${comment.id}" data-level="${level}">
            ${level > 0 ? '<div class="reply-line"></div>' : ''}
            <div class="comment-content-wrapper">
              <div class="comment-header">
                <div class="comment-author">
                  <div class="comment-avatar">${comment.user.charAt(0).toUpperCase()}</div>
                  <strong>${comment.user}</strong>
                  <span class="comment-time">${timeAgo}</span>
                </div>
              </div>
              <div class="comment-content">${comment.text}</div>
              <div class="comment-actions">
                <button class="comment-like-btn" onclick="likeComment('${postId}', '${comment.id}')">
                  <span class="reaction-icon">â¤ï¸</span>
                  <span class="like-count">${comment.likes || 0}</span>
                </button>
                <button class="reply-btn" onclick="showReplyForm('${postId}', '${comment.id}')">
                  <span class="reaction-icon">â†©ï¸</span>
                  <span>Reply</span>
                </button>
              </div>
              <div class="reply-form" id="reply-form-${comment.id}" style="display: none;">
                <input type="text" class="reply-input" placeholder="Write a reply..." maxlength="1000" />
                <div class="reply-form-actions">
                  <button class="btn btn-primary reply-submit" onclick="addReply('${postId}', '${comment.id}', this)">Reply</button>
                  <button class="btn btn-outline reply-cancel" onclick="hideReplyForm('${comment.id}')">Cancel</button>
                </div>
              </div>
            </div>
            ${hasReplies ? `<div class="replies">${replies}</div>` : ''}
          </div>
        `;
      }).join('');
    }

    // Post interactions
    async function likePost(postId) {
      try {
        const response = await fetch(`/api/posts/${postId}/like`, {
          method: 'POST'
        });
        
        if (response.ok) {
          const result = await response.json();
          const likeBtn = document.querySelector(`[data-post-id="${postId}"] .like-btn`);
          const likeCount = likeBtn.querySelector('.like-count');
          
          likeCount.textContent = result.likes;
          
          // Animate heart
          likeBtn.classList.add('pulse');
          setTimeout(() => likeBtn.classList.remove('pulse'), 300);
          
          // Update local data
          const post = allPosts.find(p => p._id === postId);
          if (post) post.likes = result.likes;
        }
      } catch (error) {
        console.error('Error liking post:', error);
        showNotification('Failed to like post', 'error');
      }
    }

    async function likeComment(postId, commentId) {
      try {
        const response = await fetch(`/api/posts/${postId}/comments/${commentId}/like`, {
          method: 'POST'
        });
        
        if (response.ok) {
          const result = await response.json();
          const likeBtn = document.querySelector(`[data-comment-id="${commentId}"] .comment-like-btn`);
          const likeCount = likeBtn.querySelector('.like-count');
          
          likeCount.textContent = result.likes;
          
          // Animate heart
          likeBtn.classList.add('pulse');
          setTimeout(() => likeBtn.classList.remove('pulse'), 300);
        }
      } catch (error) {
        console.error('Error liking comment:', error);
        showNotification('Failed to like comment', 'error');
      }
    }

    function toggleComments(postId) {
      const commentsSection = document.getElementById(`comments-${postId}`);
      const commentBtn = document.querySelector(`[data-post-id="${postId}"] .comment-btn`);
      
      if (commentsSection.style.display === 'none') {
        commentsSection.style.display = 'block';
        commentsSection.classList.add('slide-in');
        commentBtn.classList.add('active');
        
        // Focus on comment input
        const commentInput = commentsSection.querySelector('.comment-input');
        setTimeout(() => commentInput.focus(), 300);
      } else {
        commentsSection.style.display = 'none';
        commentsSection.classList.remove('slide-in');
        commentBtn.classList.remove('active');
      }
    }

    async function addComment(postId, button) {
      const commentInput = button.parentElement.querySelector('.comment-input');
      const text = commentInput.value.trim();
      
      if (!text) {
        showNotification('Please enter a comment', 'warning');
        return;
      }
      
      if (!savedUsername) {
        showNotification('Please set your username first', 'warning');
        return;
      }

      try {
        button.disabled = true;
        button.textContent = 'Posting...';
        
        const response = await fetch(`/api/posts/${postId}/comments`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            user: savedUsername,
            text: text
          })
        });

        if (response.ok) {
          const comment = await response.json();
          
          // Clear input
          commentInput.value = '';
          
          // Update comments list
          await refreshComments(postId);
          
          // Update comment count
          const commentBtn = document.querySelector(`[data-post-id="${postId}"] .comment-btn .comment-count`);
          const currentCount = parseInt(commentBtn.textContent) || 0;
          commentBtn.textContent = currentCount + 1;
          
          showNotification('Comment added successfully! ğŸ’¬', 'success');
        } else {
          const error = await response.json();
          showNotification(error.error || 'Failed to add comment', 'error');
        }
      } catch (error) {
        console.error('Error adding comment:', error);
        showNotification('Failed to add comment', 'error');
      } finally {
        button.disabled = false;
        button.textContent = 'Post';
      }
    }

    async function addReply(postId, parentId, button) {
      const replyInput = button.parentElement.parentElement.querySelector('.reply-input');
      const text = replyInput.value.trim();
      
      if (!text) {
        showNotification('Please enter a reply', 'warning');
        return;
      }
      
      if (!savedUsername) {
        showNotification('Please set your username first', 'warning');
        return;
      }

      try {
        button.disabled = true;
        button.textContent = 'Replying...';
        
        const response = await fetch(`/api/posts/${postId}/comments`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            user: savedUsername,
            text: text,
            parentId: parentId
          })
        });

        if (response.ok) {
          const reply = await response.json();
          
          // Clear input and hide form
          replyInput.value = '';
          hideReplyForm(parentId);
          
          // Update comments list
          await refreshComments(postId);
          
          // Update comment count
          const commentBtn = document.querySelector(`[data-post-id="${postId}"] .comment-btn .comment-count`);
          const currentCount = parseInt(commentBtn.textContent) || 0;
          commentBtn.textContent = currentCount + 1;
          
          showNotification('Reply added successfully! ğŸ’¬', 'success');
        } else {
          const error = await response.json();
          showNotification(error.error || 'Failed to add reply', 'error');
        }
      } catch (error) {
        console.error('Error adding reply:', error);
        showNotification('Failed to add reply', 'error');
      } finally {
        button.disabled = false;
        button.textContent = 'Reply';
      }
    }

    function showReplyForm(postId, commentId) {
      // Hide all other reply forms
      document.querySelectorAll('.reply-form').forEach(form => {
        if (form.id !== `reply-form-${commentId}`) {
          form.style.display = 'none';
        }
      });
      
      const replyForm = document.getElementById(`reply-form-${commentId}`);
      replyForm.style.display = 'block';
      replyForm.classList.add('slide-in');
      
      // Focus on reply input
      const replyInput = replyForm.querySelector('.reply-input');
      setTimeout(() => replyInput.focus(), 100);
    }

    function hideReplyForm(commentId) {
      const replyForm = document.getElementById(`reply-form-${commentId}`);
      replyForm.style.display = 'none';
      replyForm.classList.remove('slide-in');
    }

    async function refreshComments(postId) {
      try {
        const response = await fetch(`/api/posts?limit=1000`);
        const posts = await response.json();
        const post = posts.find(p => p._id === postId);
        
        if (post) {
          const commentsList = document.getElementById(`comments-list-${postId}`);
          commentsList.innerHTML = buildCommentsHTML(post.comments || [], postId);
          
          // Update local data
          const localPost = allPosts.find(p => p._id === postId);
          if (localPost) {
            localPost.comments = post.comments;
          }
        }
      } catch (error) {
        console.error('Error refreshing comments:', error);
      }
    }

    function sharePost(postId) {
      const url = `${window.location.origin}/#post-${postId}`;
      
      if (navigator.share) {
        navigator.share({
          title: 'Check out this post!',
          url: url
        });
      } else {
        navigator.clipboard.writeText(url).then(() => {
          showNotification('Post link copied to clipboard! ğŸ”—', 'success');
        }).catch(() => {
          showNotification('Failed to copy link', 'error');
        });
      }
    }

    // Lightbox functionality
    function openLightbox(src, type) {
      const lightbox = document.getElementById('lightbox');
      const mediaContainer = lightbox.querySelector('.lightbox-media');
      
      if (type === 'image') {
        mediaContainer.innerHTML = `<img src="${src}" alt="Lightbox image" />`;
      } else if (type === 'video') {
        mediaContainer.innerHTML = `
          <video controls autoplay>
            <source src="${src}" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        `;
      }
      
      lightbox.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      
      // Set download link
      const filename = src.split('/').pop();
      document.getElementById('lightbox-download').onclick = () => downloadFile(src, filename);
    }

    function closeLightbox() {
      const lightbox = document.getElementById('lightbox');
      lightbox.style.display = 'none';
      document.body.style.overflow = 'auto';
    }

    // Close lightbox on click outside or escape key
    document.getElementById('lightbox').addEventListener('click', (e) => {
      if (e.target.id === 'lightbox') closeLightbox();
    });

    document.querySelector('.lightbox-close').addEventListener('click', closeLightbox);

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeLightbox();
    });

    function downloadFile(url, filename) {
      const a = document.createElement('a');
      a.href = url;
      a.download = filename || url.split('/').pop() || 'download';
      a.target = '_blank';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      showNotification('Download started', 'success');
    }

    // Utility functions
    function getTimeAgo(date) {
      const now = new Date();
      const diffInSeconds = Math.floor((now - date) / 1000);
      
      if (diffInSeconds < 60) return 'just now';
      if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
      if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
      if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
      
      return date.toLocaleDateString();
    }

    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.classList.add('show');
      }, 100);
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    // Event Listeners
    document.getElementById('refresh-btn').addEventListener('click', () => {
      loadPosts(true);
      showNotification('Posts refreshed! ğŸ”„', 'success');
    });

    document.getElementById('sort-select').addEventListener('change', (e) => {
      currentSort = e.target.value;
      sortPosts();
      displayPosts(true);
      showNotification(`Sorted by ${e.target.selectedOptions[0].text}`, 'info');
    });

    document.getElementById('load-more-btn').addEventListener('click', () => {
      loadPosts(false);
    });

    // Scroll to Top Button
    const scrollTopBtn = document.getElementById('scroll-top');
    
    window.addEventListener('scroll', () => {
      if (window.pageYOffset > 300) {
        scrollTopBtn.classList.add('visible');
      } else {
        scrollTopBtn.classList.remove('visible');
      }
    });

    scrollTopBtn.addEventListener('click', () => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      loadPosts(true);
      
      // Add intersection observer for animations
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('fade-in');
          }
        });
      });

      // Observe all cards for animation
      document.querySelectorAll('.card').forEach(card => {
        observer.observe(card);
      });

      // Handle keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case 'r':
              e.preventDefault();
              loadPosts(true);
              break;
          }
        }
      });
    });

    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(registration => {
          console.log('SW registered:', registration);
        })
        .catch(error => {
          console.log('SW registration failed:', error);
        });
    }
  </script>
</body>
</html>